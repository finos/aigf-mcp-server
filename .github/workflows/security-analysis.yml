name: Security Analysis & Code Quality

on:
  push:
    branches: [ main, develop, 'feature/*', 'hotfix/*' ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Run security scans weekly on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    # Allow manual triggering

permissions:
  contents: read
  security-events: write
  actions: read

jobs:
  security-scan:
    name: Security & Quality Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 30

    strategy:
      matrix:
        python-version: [3.11, 3.12, 3.13]
      fail-fast: false

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # Full history needed for some security scanners
        fetch-depth: 0


    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .[security,dev]
        pip install lxml  # Required for MyPy report generation

    - name: Create directories
      run: |
        mkdir -p security-reports
        mkdir -p coverage-reports


    # Static Analysis with Bandit - STRICT: Will fail on high/medium severity issues
    - name: Run Bandit Security Scanner
      id: bandit
      run: |
        echo "Running Bandit security scanner..."
        python -m bandit -c config/security/bandit.yml -r src/ \
          --format json \
          --output security-reports/bandit-report.json \
          --severity-level low \
          --confidence-level medium

        # Check if any HIGH or MEDIUM severity issues were found
        HIGH_ISSUES=$(jq '[.results[] | select(.issue_severity == "HIGH")] | length' security-reports/bandit-report.json)
        MEDIUM_ISSUES=$(jq '[.results[] | select(.issue_severity == "MEDIUM")] | length' security-reports/bandit-report.json)

        echo "Bandit found $HIGH_ISSUES high severity and $MEDIUM_ISSUES medium severity issues"

        if [ "$HIGH_ISSUES" -gt 0 ]; then
          echo "‚ùå CRITICAL: Bandit found $HIGH_ISSUES high severity security issues"
          jq '.results[] | select(.issue_severity == "HIGH")' security-reports/bandit-report.json
          exit 1
        fi

        # Threshold is 0: every accepted false positive must be suppressed with
        # an inline '# nosec BXXX' comment that documents the rationale, rather
        # than relying on a numerical tolerance that can silently accumulate.
        if [ "$MEDIUM_ISSUES" -gt 0 ]; then
          echo "‚ùå FAILURE: Bandit found $MEDIUM_ISSUES medium severity issues (threshold: 0)"
          echo "  Suppress accepted false positives with '# nosec BXXX' and a rationale comment."
          jq '.results[] | select(.issue_severity == "MEDIUM")' security-reports/bandit-report.json
          exit 1
        fi

        echo "‚úÖ Bandit security scan passed"

    # Static Analysis with Semgrep - STRICT: Will fail on ERROR level findings
    - name: Run Semgrep Static Analysis
      id: semgrep
      run: |
        echo "Running Semgrep static analysis..."
        ./scripts/semgrep-isolated.sh --config config/security/semgrep.yml src/ \
          --json \
          --output security-reports/semgrep-report.json \
          --metrics=off

        # Check for ERROR level findings
        ERROR_ISSUES=$(jq '[.results[] | select(.extra.severity == "ERROR")] | length' security-reports/semgrep-report.json)
        WARNING_ISSUES=$(jq '[.results[] | select(.extra.severity == "WARNING")] | length' security-reports/semgrep-report.json)

        echo "Semgrep found $ERROR_ISSUES errors and $WARNING_ISSUES warnings"

        if [ "$ERROR_ISSUES" -gt 0 ]; then
          echo "‚ùå CRITICAL: Semgrep found $ERROR_ISSUES critical security issues"
          jq '.results[] | select(.extra.severity == "ERROR")' security-reports/semgrep-report.json
          exit 1
        fi

        echo "‚úÖ Semgrep security scan passed"

    # Code Quality with Pylint - STRICT: Will fail below minimum score
    - name: Run Pylint Code Analysis
      id: pylint
      run: |
        echo "Running Pylint code quality analysis..."
        set +e  # Temporarily disable exit on error to capture Pylint exit code
        python -m pylint src/ \
          --output-format=json \
          --reports=yes \
          --score=yes > security-reports/pylint-report.json
        PYLINT_EXIT_CODE=$?
        set -e  # Re-enable exit on error

        if [ $PYLINT_EXIT_CODE -ne 0 ]; then
          echo "‚ùå CRITICAL: Pylint score below 8.5 threshold (exit code: $PYLINT_EXIT_CODE)"
          echo "üìã Detailed Pylint report:"
          cat security-reports/pylint-report.json | jq '.[] | select(.type == "fatal" or .type == "error") | {type, message, path, line}'
          exit 1
        fi

        echo "‚úÖ Pylint code quality check passed"

    # Code Quality with Ruff - STRICT: Will fail on any issues
    - name: Run Ruff Linter
      id: ruff
      run: |
        echo "Running Ruff linter..."
        set +e  # Temporarily disable exit on error to capture Ruff exit code
        ruff check src/ tests/ scripts/ --output-format=json > security-reports/ruff-report.json
        RUFF_EXIT_CODE=$?
        set -e  # Re-enable exit on error

        # Count the number of issues found
        RUFF_ISSUES=$(jq 'length' security-reports/ruff-report.json)
        echo "Ruff found $RUFF_ISSUES linting issues"

        # CRITICAL: Fail if Ruff found any issues (explicit exit code check)
        if [ $RUFF_EXIT_CODE -ne 0 ]; then
          echo "‚ùå CRITICAL: Ruff found $RUFF_ISSUES linting issues"
          echo "üìã Detailed Ruff issues:"
          jq '.' security-reports/ruff-report.json
          exit 1
        fi

        # Check formatting
        echo "Checking code formatting with Ruff..."
        ruff format --check src/ tests/ scripts/

        echo "‚úÖ Ruff linting and formatting checks passed"

    # Type Checking with MyPy - STRICT: Will fail on type errors
    - name: Run MyPy Type Checking
      id: mypy
      run: |
        echo "Running MyPy type checking..."
        python -m mypy src/finos_mcp \
          --show-error-codes \
          --show-error-context \
          --txt-report security-reports/mypy-report \
          --strict-optional \
          --warn-redundant-casts \
          --warn-unused-ignores

        echo "‚úÖ MyPy type checking passed - no type errors found"

    # Run actual tests - STRICT: Must pass
    - name: Run All Tests
      id: tests
      run: |
        echo "Running all tests..."
        python -m pytest tests/ \
          --cov=src/finos_mcp \
          --cov-report=json:coverage-reports/coverage.json \
          --cov-report=xml:coverage-reports/coverage.xml \
          --cov-report=html:coverage-reports/html \
          --junit-xml=coverage-reports/pytest.xml \
          --cov-fail-under=65 \
          --tb=short \
          --quiet

        # Extract and display coverage metrics
        if [ -f "coverage-reports/coverage.json" ]; then
          COVERAGE=$(python -c "import json; data=json.load(open('coverage-reports/coverage.json')); print(f'{data[\"totals\"][\"percent_covered\"]:.1f}%')" 2>/dev/null || echo "unknown")
          echo "üìä Test Coverage: $COVERAGE"
        fi

        echo "‚úÖ All tests passed"

    # Dependency Vulnerability Scanning - STRICT: Will fail on known vulnerabilities
    - name: Run pip-audit Dependency Scanner
      id: pip-audit
      run: |
        echo "Running pip-audit dependency vulnerability scanner..."
        pip freeze > security-reports/requirements.txt

        # Install pip-audit (Python Packaging Authority's official tool)
        python -m pip install pip-audit

        # Run pip-audit scan - fail on any known vulnerabilities
        # Ignored vulnerabilities (no fix available ‚Äî re-review each quarter):
        # - GHSA-7gcm-g887-7qv7: protobuf DoS via JSON recursion (CVE-2026-0994)
        #   Transitive dep from semgrep->opentelemetry->protobuf. No fix as of 2026-01.
        #   Low risk: affects ParseDict() for untrusted JSON, not used by this server.
        #   REVIEW-BY: 2026-04-01. Remove suppression once protobuf >= patched version.
        # - GHSA-w8v5-vhqr-4h9v: diskcache vulnerability with no patched release available.
        #   Transitive dep from fastmcp->py-key-value-aio. Tracked until upstream ships a fix.
        #   REVIEW-BY: 2026-04-01. Remove suppression once diskcache ships a patched release.
        pip-audit --format json --output security-reports/pip-audit-report.json \
          --ignore-vuln GHSA-7gcm-g887-7qv7 \
          --ignore-vuln GHSA-w8v5-vhqr-4h9v

        # Check for vulnerabilities - handle both old and new pip-audit output formats
        VULNS=$(jq 'if type == "array" then map(select(.vulns? | length? > 0)) | length elif .dependencies then .dependencies | map(select(.vulns | length > 0)) | length else 0 end' security-reports/pip-audit-report.json)

        if [ "$VULNS" -gt 0 ]; then
          echo "‚ùå CRITICAL: Found vulnerabilities in $VULNS dependencies"
          if jq -e '.dependencies' security-reports/pip-audit-report.json > /dev/null; then
            jq '.dependencies | map(select(.vulns | length > 0))' security-reports/pip-audit-report.json
          else
            jq 'map(select(.vulns? | length? > 0))' security-reports/pip-audit-report.json
          fi
          exit 1
        fi

        echo "‚úÖ No known vulnerabilities found in dependencies"

    # Upload Security Reports as Artifacts (only if we get this far)
    - name: Upload Security Reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-reports-py${{ matrix.python-version }}
        path: security-reports/
        retention-days: 30

    # Upload Coverage Reports
    - name: Upload Coverage Reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-reports-py${{ matrix.python-version }}
        path: coverage-reports/
        retention-days: 30

    # Final Security Summary - Only runs if all checks passed
    - name: Security Analysis Summary
      if: success()
      run: |
        echo "## ‚úÖ Security Analysis Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "All security and quality checks passed successfully!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Results:" >> $GITHUB_STEP_SUMMARY
        echo "- üîí **Bandit**: No critical security issues" >> $GITHUB_STEP_SUMMARY
        echo "- üîç **Semgrep**: No security vulnerabilities" >> $GITHUB_STEP_SUMMARY
        echo "- üìã **Pylint**: Code quality standards met" >> $GITHUB_STEP_SUMMARY
        echo "- ‚ö° **Ruff**: Code style and linting passed" >> $GITHUB_STEP_SUMMARY
        echo "- üéØ **MyPy**: Type checking passed" >> $GITHUB_STEP_SUMMARY
        echo "- üß™ **Tests**: All tests passed" >> $GITHUB_STEP_SUMMARY
        echo "- üîê **pip-audit**: No known vulnerabilities" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "üìä Detailed reports available in workflow artifacts" >> $GITHUB_STEP_SUMMARY

  # Only run if security scan job succeeded
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: security-scan
    if: success()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: 3.11
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .[dev]

    - name: Run Integration Tests
      run: |
        echo "Running integration tests..."
        export FINOS_MCP_CACHE_SECRET=test_cache_secret_for_ci_integration_32chars
        # Test that the MCP server can actually start and respond
        timeout 30 python -c "
        import asyncio
        import sys
        sys.path.insert(0, 'src')

        async def test_server_startup():
            try:
                from finos_mcp.fastmcp_main import main
                from finos_mcp.content.service import get_content_service
                print('‚úÖ Server imports successful')

                # Test service initialization
                service = await get_content_service()
                print('‚úÖ Content service initialization successful')

                print('‚úÖ Integration tests passed')
            except Exception as e:
                print(f'‚ùå Integration test failed: {e}')
                sys.exit(1)

        asyncio.run(test_server_startup())
        "
