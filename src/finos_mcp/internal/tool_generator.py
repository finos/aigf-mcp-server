"""
MCP tool generator with code templates.
Simple tool generator for creating MCP tools from templates.
"""

import re
from dataclasses import dataclass
from pathlib import Path
from typing import Any


@dataclass
class ToolTemplate:
    """Template configuration for generating MCP tools."""

    name: str
    description: str
    input_schema: dict[str, Any]
    custom_logic: str = ""


@dataclass
class GeneratedTool:
    """Generated tool with code and tests."""

    name: str
    description: str
    code: str
    test_code: str


class ToolGenerator:
    """Simple MCP tool generator."""

    def __init__(self):
        """Initialize tool generator."""
        pass

    def generate_tool(self, template: ToolTemplate) -> GeneratedTool:
        """Generate tool code from template."""
        self._validate_template(template)

        # Generate components
        pydantic_model = self._generate_pydantic_model(
            self._to_pascal_case(template.name) + "Request", template.input_schema
        )
        tool_definition = self._generate_tool_definition(template)
        handler_function = self._generate_handler_function(template)

        # Combine into full code
        code = f'''"""
{template.description} tool.
Generated by MCP tool generator.
"""

from typing import Any

from mcp.types import TextContent, Tool
from pydantic import BaseModel, Field

from ..logging import get_logger

logger = get_logger("{template.name}_tool")

{pydantic_model}

# Tool definition
{template.name.upper()}_TOOL = {tool_definition}

{handler_function}
'''

        # Generate test code
        test_code = self._generate_test_code(template)

        return GeneratedTool(
            name=template.name,
            description=template.description,
            code=code,
            test_code=test_code,
        )

    async def write_tool_files(
        self, generated: GeneratedTool, output_dir: Path
    ) -> dict[str, Path]:
        """Write generated tool to files."""
        output_dir.mkdir(parents=True, exist_ok=True)

        # Write tool file
        tool_file = output_dir / f"{generated.name}.py"
        with open(tool_file, "w") as f:
            f.write(generated.code)

        # Write test file
        test_file = output_dir / f"test_{generated.name}.py"
        with open(test_file, "w") as f:
            f.write(generated.test_code)

        return {"tool_file": tool_file, "test_file": test_file}

    def _validate_template(self, template: ToolTemplate) -> None:
        """Validate template configuration."""
        if not template.name.strip():
            raise ValueError("Tool name cannot be empty")

        if not template.input_schema:
            raise ValueError("Input schema is required")

    def _to_snake_case(self, name: str) -> str:
        """Convert name to snake_case."""
        # Insert underscore before uppercase letters that follow lowercase letters
        s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
        # Insert underscore before uppercase letters that are followed by lowercase letters
        return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()

    def _to_pascal_case(self, name: str) -> str:
        """Convert name to PascalCase."""
        # If already PascalCase, return as-is
        if name and name[0].isupper() and "_" not in name and "-" not in name:
            return name
        return "".join(word.capitalize() for word in name.replace("-", "_").split("_"))

    def _generate_pydantic_model(self, class_name: str, schema: dict[str, Any]) -> str:
        """Generate Pydantic model from JSON schema."""
        properties = schema.get("properties", {})
        required = schema.get("required", [])

        fields = []
        for prop_name, prop_info in properties.items():
            prop_type = self._json_type_to_python(prop_info["type"])
            description = prop_info.get("description", "")
            default_value = prop_info.get("default")

            if prop_name in required:
                if default_value is not None:
                    fields.append(
                        f'    {prop_name}: {prop_type} = Field(default={default_value!r}, description="{description}")'
                    )
                else:
                    fields.append(
                        f'    {prop_name}: {prop_type} = Field(..., description="{description}")'
                    )
            else:
                if default_value is not None:
                    fields.append(
                        f'    {prop_name}: {prop_type} = Field(default={default_value!r}, description="{description}")'
                    )
                else:
                    fields.append(
                        f'    {prop_name}: {prop_type} | None = Field(default=None, description="{description}")'
                    )

        return f"""class {class_name}(BaseModel):
    \"\"\"Request model for {class_name.replace("Request", "").lower()}.\"\"\"

{chr(10).join(fields)}"""

    def _json_type_to_python(self, json_type: str) -> str:
        """Convert JSON schema type to Python type."""
        type_map = {
            "string": "str",
            "integer": "int",
            "number": "float",
            "boolean": "bool",
            "array": "list",
            "object": "dict",
        }
        return type_map.get(json_type, "Any")

    def _generate_tool_definition(self, template: ToolTemplate) -> str:
        """Generate MCP tool definition."""
        return f'''Tool(
        name="{template.name}",
        description="{template.description}",
        inputSchema={template.input_schema},
    )'''

    def _generate_handler_function(self, template: ToolTemplate) -> str:
        """Generate tool handler function."""
        request_class = self._to_pascal_case(template.name) + "Request"

        # Use custom logic if provided, otherwise return simple response
        if template.custom_logic:
            logic = template.custom_logic
        else:
            logic = f'''result = {{"status": "success", "tool": "{template.name}", "arguments": arguments}}
    return [TextContent(type="text", text=str(result))]'''

        return f"""async def handle_{template.name}_tool(
    name: str, arguments: dict[str, Any]
) -> list[TextContent]:
    \"\"\"Handle {template.name} tool calls.\"\"\"
    logger.debug("Handling tool: %s", name, extra={{"tool_name": name, "arguments": arguments}})

    # Validate input
    request = {request_class}(**arguments)

    # Process request
    {logic}"""

    def _generate_test_code(self, template: ToolTemplate) -> str:
        """Generate test code for the tool."""
        class_name = self._to_pascal_case(template.name)
        request_class = class_name + "Request"

        # Get first required field for test
        properties = template.input_schema.get("properties", {})
        required = template.input_schema.get("required", [])
        test_field = (
            required[0]
            if required
            else next(iter(properties.keys()))
            if properties
            else "test"
        )

        return f'''"""
Tests for {template.name} tool.
Generated by MCP tool generator.
"""

import pytest
from unittest.mock import Mock

from {template.name} import {request_class}, handle_{template.name}_tool


class Test{class_name}:
    """Test {template.name} tool."""

    def test_{template.name}_request_validation(self):
        """Test request validation."""
        # Valid request
        request = {request_class}({test_field}="test_value")
        assert request.{test_field} == "test_value"

        # Invalid request should raise validation error
        with pytest.raises(Exception):  # Pydantic validation error
            {request_class}()

    @pytest.mark.asyncio
    async def test_handle_{template.name}_tool(self):
        """Test tool handler."""
        arguments = {{"{test_field}": "test_value"}}

        result = await handle_{template.name}_tool("{template.name}", arguments)

        assert len(result) == 1
        assert result[0].type == "text"
        assert "test_value" in result[0].text or "success" in result[0].text
'''
